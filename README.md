# PyDis - Python Bytecode Disassembler

A GUI-based educational tool for disassembling Python code into bytecode, exploring its structure, and understanding Python's internal execution mechanisms.

## Overview

PyDis is a desktop application that allows for the disassembly of Python code (entire files or snippets) using Python's built-in `dis` module. It provides a clean, intuitive interface for viewing and understanding Python bytecode while offering features for step-by-step execution, variable inspection, and I/O handling.

## Features

- **Code Input**: Paste Python code snippets or load entire Python files
- **Bytecode Disassembly**: Convert Python code into its bytecode representation
- **Dual View**: See both Python source code and corresponding bytecode side-by-side
- **Step-by-step Execution**: Execute code one step at a time to observe changes
- **Variable Inspection**: Monitor variable values during execution
- **I/O Handling**: Capture and display standard output and error streams
- **Bytecode Export**: Save disassembled bytecode in various formats (text, binary, JSON, markdown report)

## Screenshot

![application](imgs/demo.png)

## Installation

PyDis requires Python 3.8 or higher and uses the Tkinter GUI library which is included in standard Python distributions.

### Option 1: Download Executable (Recommended for Users)

**[ðŸ“¥ Download PyDis v1.0 - Windows Executable](https://github.com/dylantcon/pydis/releases/latest/download/pydis.exe)**

1. Click the download link above
2. Save the `pydis.exe` file to your desired location
3. Double-click to launch PyDis
4. No Python installation required!

*Note: The executable is built for Windows. For other platforms, use the source code installation below.*

### Option 2: Run from Source Code

#### Command-Line Launch
1. Clone this repository:
    ```bash
    git clone https://github.com/yourusername/pydis.git
    cd pydis
    ```

2. Run the application:
    ```bash
    python pydis.py
    ```

#### Building Your Own Executable
If you want to build the executable yourself:

1. Install PyInstaller:
    ```bash
    pip install pyinstaller
    ```

2. Build the executable:
    ```bash
    pyinstaller pydis.spec
    ```

3. Find the executable in the `dist/` folder

## System Requirements

- **For Executable**: Windows 10 or later (no additional requirements)
- **For Source**: Python 3.8+ with Tkinter (included in most Python distributions)
- **Memory**: Minimum 4GB RAM recommended for analyzing large Python files
- **Storage**: ~11MB for executable, +50MB for source

## Usage

1. **New/Open File**: Start with a new file or open an existing Python file
2. **Write or Edit Code**: Use the code editor to write or modify Python code
3. **Disassemble**: Click the "Disassemble" button to convert the code to bytecode
4. **Execute or Debug**: Run the code normally or step through it with the debugger
5. **Examine Bytecode**: View the generated bytecode in text or table format
6. **Save Results**: Save your Python code or export the bytecode in various formats

## Key Shortcuts

- **Ctrl+N**: New file
- **Ctrl+O**: Open file
- **Ctrl+S**: Save file
- **F5**: Execute code
- **F9**: Disassemble code
- **F10**: Debug (step-by-step execution)

## Educational Use

PyDis is designed as a teaching tool for Python internals and can be used to:

- Demonstrate how Python code is translated to bytecode
- Explain Python's execution model
- Visualize program flow at the bytecode level
- Compare different code constructs and their bytecode efficiency
- Introduce concepts of virtual machines and bytecode interpretation

## Project Structure

```
pydis/
â”œâ”€â”€ main.py                  # Application entry point
â”œâ”€â”€ requirements.txt         # Dependencies
â”œâ”€â”€ README.md                # Documentation
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ core/                # Core functionality
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ disassembler.py  # Bytecode disassembly logic
â”‚   â”‚   â”œâ”€â”€ executor.py      # Code execution engine
â”‚   â”‚   â””â”€â”€ file_handler.py  # File I/O operations
â”‚   â”œâ”€â”€ gui/                 # GUI components
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ app.py           # Main application window
â”‚   â”‚   â”œâ”€â”€ code_view.py     # Code editor/display component
â”‚   â”‚   â”œâ”€â”€ bytecode_view.py # Bytecode display component
â”‚   â”‚   â”œâ”€â”€ toolbar.py       # Application toolbar
â”‚   â”‚   â””â”€â”€ debugger.py      # Step-by-step execution UI
â”‚   â””â”€â”€ utils/               # Utility functions
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ resources.py        # Resource management
â””
```

### Debugger Sequence Diagram

```mermaid
sequenceDiagram
    participant User
    participant UIThread as UI Thread<br/>(PyDisApp)
    participant Executor
    participant ExecThread as Execution Thread<br/>(_run_with_trace)
    participant Interpreter as Python Interpreter<br/>(PVM)
    participant TraceFunc as Trace Function<br/>(_trace_function)

    Note over User, TraceFunc: Debug Session Initialization

    User->>+UIThread: Click "Debug" button
    UIThread->>UIThread: Get source code from editor
    UIThread->>+Executor: execute_step_by_step(source_code)
    
    Executor->>Executor: reset() - Clear previous state
    Executor->>Executor: _is_running = True
    
    Executor->>+ExecThread: Create thread(_run_with_trace, source_code)
    Note right of ExecThread: Thread created with daemon=True
    Executor->>ExecThread: start() - Begin execution thread
    Executor-->>-UIThread: Return (non-blocking)
    UIThread-->>-User: UI ready for debugging

    Note over ExecThread, TraceFunc: Execution Thread Initialization

    ExecThread->>+Interpreter: sys.settrace(_trace_function)
    ExecThread->>Interpreter: compile(source_code, '<string>', 'exec')
    ExecThread->>+Interpreter: exec(compiled_code, globals, locals)
    
    Note over Interpreter, TraceFunc: First Line Execution

    Interpreter->>+TraceFunc: Call before first line (frame, 'line', arg)
    TraceFunc->>TraceFunc: Record execution state
    TraceFunc->>Executor: _step_event.clear()
    TraceFunc->>Executor: _step_complete_event.set()
    Note right of TraceFunc: Signal UI: step complete, state ready
    
    TraceFunc->>TraceFunc: _step_event.wait()
    Note right of TraceFunc: THREAD BLOCKS - waiting for UI signal
    
    Note over User, TraceFunc: Step-by-Step Execution Cycle

    loop Each Step Command
        User->>+UIThread: Click "Step" button
        UIThread->>+Executor: step()
        
        Executor->>Executor: _step_event.set()
        Note right of Executor: Signal execution thread to proceed
        
        Executor->>Executor: _step_complete_event.wait(timeout=1.0)
        Note right of Executor: UI THREAD BLOCKS - waiting for step completion
        
        Note over TraceFunc, Interpreter: Execution Thread Resumes
        TraceFunc->>TraceFunc: _step_event.wait() unblocks
        TraceFunc->>TraceFunc: _step_complete_event.clear()
        TraceFunc-->>Interpreter: return self._trace_function
        Note right of TraceFunc: Tell interpreter to continue tracing
        
        Interpreter->>Interpreter: Execute one line of user code
        Interpreter->>+TraceFunc: Call before next line (frame, 'line', arg)
        
        TraceFunc->>TraceFunc: Record new execution state
        TraceFunc->>Executor: _step_event.clear()
        TraceFunc->>Executor: _step_complete_event.set()
        Note right of TraceFunc: Signal UI: step complete
        
        Executor->>Executor: _step_complete_event.wait() unblocks
        Executor-->>-UIThread: step() returns
        
        UIThread->>+UIThread: _update_debug_ui()
        UIThread->>UIThread: Get execution state from executor
        UIThread->>UIThread: Update variable inspector
        UIThread->>UIThread: Update console output
        UIThread->>UIThread: Highlight current line in code view
        UIThread->>UIThread: Highlight bytecode instructions
        UIThread-->>-User: Display updated debug state
        
        TraceFunc->>TraceFunc: _step_event.wait()
        Note right of TraceFunc: THREAD BLOCKS again - waiting for next step
        
    end

    Note over User, TraceFunc: Debug Session Termination

    User->>+UIThread: Click "Stop" button
    UIThread->>+Executor: stop_execution()
    Executor->>Executor: _should_stop = True
    Executor->>Executor: _step_event.set()
    Note right of Executor: Unblock execution thread
    Executor-->>-UIThread: Return
    
    TraceFunc->>TraceFunc: _step_event.wait() unblocks
    TraceFunc->>TraceFunc: Check _should_stop == True
    TraceFunc-->>-Interpreter: return None
    Note right of TraceFunc: Tell interpreter to stop tracing
    
    Interpreter->>Interpreter: Disable tracing, continue at normal speed
    Interpreter-->>-ExecThread: exec() completes
    ExecThread->>ExecThread: sys.settrace(None) - cleanup
    ExecThread->>ExecThread: Restore stdout/stderr
    ExecThread->>Executor: _is_running = False
    ExecThread-->>-Executor: Thread terminates
    
    UIThread-->>-User: Debug session ended
```

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgments

- This project was inspired by the need for better educational tools for teaching Python bytecode concepts
- Thanks to Python's `dis` module for making bytecode disassembly accessible programmatically
